;;;; puzzle.lisp
;;;; Lógica específica do Peg Solitaire (Construída com base no LAB07)
;;;; Projeto01 IA - 25/26

;;; Representação do Tabuleiro (exemplo de teste incluído)
(defun tabuleiro-inicial ()
"Tabuleiro inicial padrão com uma posição vazia no centro."
  '(
    (nil nil 1 1 1 nil nil)
    (nil nil 1 1 1 nil nil)
    (1 1 1 1 1 1 1)
    (1 1 1 0 1 1 1)
    (1 1 1 1 1 1 1)
    (nil nil 1 1 1 nil nil)
    (nil nil 1 1 1 nil nil)))

;;; Seletores

;; Teste: (linha 1 (tabuleiro-inicial)) 
(defun linha (i tabuleiro)
"Função que recebe um índice e o tabuleiro e retorna uma lista que representa essa linha do
 tabuleiro."
  (nth (1- i) tabuleiro))

;; Teste: (coluna 1 (tabuleiro-inicial)) 
(defun coluna (j tabuleiro)
"Função que recebe um índice e o tabuleiro e retorna uma lista que representa essa coluna do
 tabuleiro."
  (mapcar (lambda (linha) (nth (1- j) linha)) tabuleiro))

;; Teste: (celula 4 4 (tabuleiro-inicial))
(defun celula (i j tabuleiro)
"Função que recebe dois índices e o tabuleiro e retorna o valor presente nessa célula do
 tabuleiro."
  (let ((row (linha i tabuleiro)))
    (if row (nth (1- j) row) nil)))

;;; Funções auxiliares

;; Teste: (celula-valida 1 1 (tabuleiro-inicial))
(defun celula-valida (i j tabuleiro)
"Função predicado que recebe os índices da linha e da coluna e o tabuleiro."
  (let ((val (celula i j tabuleiro)))
    (if (or (equal val 1) (equal val 0)) t nil)))

;; Teste: (substituir-posicao 3 (linha 1 (tabuleiro-inicial)) 0)
(defun substituir-posicao (n lista valor)
"Função que recebe um índice, uma lista e um valor e substitui pelo valor
 pretendido nessa posição."
  (append (subseq lista 0 (1- n))
          (list valor)
          (nthcdr n lista)))

;; Teste: (substituir 1 3 (tabuleiro-inicial) 0)
(defun substituir (i j tabuleiro valor)
"Função que recebe dois índices, o tabuleiro e um valor. A função deverá retornar o
 tabuleiro com a célula substituída pelo valor pretendido."
  (let* ((linha-atual (linha i tabuleiro))
         (nova-linha (substituir-posicao j linha-atual valor)))
    (substituir-posicao i tabuleiro nova-linha)))

;;; Operadores

;; Teste: (operador-cd 4 2 (tabuleiro-inicial))
(defun operador-cd (i j tabuleiro)
  (when (and (celula-valida i j tabuleiro)
             (equal (celula i j tabuleiro) 1)
             (equal (celula i (+ j 1) tabuleiro) 1)
             (equal (celula i (+ j 2) tabuleiro) 0))
    (let ((t1 (substituir i j tabuleiro 0)))
      (let ((t2 (substituir i (+ j 1) t1 0)))
        (substituir i (+ j 2) t2 1)))))

;; Teste: (operador-ce 4 6 (tabuleiro-inicial))
(defun operador-ce (i j tabuleiro)
  (when (and (celula-valida i j tabuleiro)
             (equal (celula i j tabuleiro) 1)
             (equal (celula i (- j 1) tabuleiro) 1)
             (equal (celula i (- j 2) tabuleiro) 0))
    (let ((t1 (substituir i j tabuleiro 0)))
      (let ((t2 (substituir i (- j 1) t1 0)))
        (substituir i (- j 2) t2 1)))))

;; Teste: (operador-cc 6 4 (tabuleiro-inicial)) 
(defun operador-cc (i j tabuleiro)
  (when (and (celula-valida i j tabuleiro)
             (equal (celula i j tabuleiro) 1)
             (equal (celula (- i 1) j tabuleiro) 1)
             (equal (celula (- i 2) j tabuleiro) 0))
    (let ((t1 (substituir i j tabuleiro 0)))
      (let ((t2 (substituir (- i 1) j t1 0)))
        (substituir (- i 2) j t2 1)))))

;; Teste: (operador-cb 2 4 (tabuleiro-inicial)) 
(defun operador-cb (i j tabuleiro)
  (when (and (celula-valida i j tabuleiro)
             (equal (celula i j tabuleiro) 1)
             (equal (celula (+ i 1) j tabuleiro) 1)
             (equal (celula (+ i 2) j tabuleiro) 0))
    (let ((t1 (substituir i j tabuleiro 0)))
      (let ((t2 (substituir (+ i 1) j t1 0)))
        (substituir (+ i 2) j t2 1)))))

;;; Objetivo

;; Teste: (objetivo? (tabuleiro-inicial))
(defun objetivo? (tabuleiro)
  (= (contar-pecas tabuleiro) 1))

;; Teste: (contar-pecas (tabuleiro-inicial))
(defun contar-pecas (tabuleiro)
  (reduce #'+ (mapcar (lambda (linha)
                        (count 1 linha))
                      tabuleiro)))